!-*-f90-*-
!! Frequently changed parameters are found in this header file:
#include "../parameters"

!! files / paths 
character(*), parameter :: kernel_path=cubepm_root//'kernels/'
character(*), parameter :: killtime_path=cubepm_root//'batch/killtime.txt' 

!! timestep parameters
real(4), parameter      :: dt_scale = 1.0
real(4), parameter 	:: dt_max = 1.0
real(4), parameter 	:: ra_max = 0.01
real(4), parameter      :: a_i = 1.0 / ( z_i + 1.0)
real(4), parameter      :: a_i_nu = 1.0 / ( z_i_nu + 1.0)

!! maximum number of timesteps (in case simulation runs off on us)
integer(4), parameter   :: max_nts = 6000

!! for restart:
logical, parameter	:: restart_ic =  .false.
integer(4), parameter   :: restart_checkpoint = 1 ! line number in input/checkpoint 

logical, parameter :: restart_kill = .false. !! Restart from kill_step
character(*), parameter :: reskill_prefix = '0.528'

real(4), parameter :: kill_remaining = 30.*60.

!! particle-particle interaction parameters
! softening length (if (|r1-r2| < rsoft) then no force)
real(4), parameter      :: rsoft = 0.1
! arbitrary timescale limiting parameter :: dt_max_pp=sqrt(dt_pp_scale*rsoft/max_pp_acceleration)
real(4), parameter      :: dt_pp_scale = 0.05
! arbitrary pp bias (set to increase the force interaction)
real(4), parameter      :: pp_bias = 1.00 !0.85 !0.1 !0.4642

!! extended pp parameters: 
!need pp_ext_force_flag=1, pp_range>0 and PP_EXT defined true to use EXT_PP
logical, parameter :: pp_ext_force_flag = .true. 
! Number of fine cell layers, for extended pp force calculation:
integer(4), parameter   :: pp_range = 2

!! halo finding parameters 
! write out entire halo catalog, or just the value of nhalo
logical, parameter      :: halo_write = .true.
! spherical overdensity cutoff for determining halo extent
real(4), parameter      :: halo_odc = 200. 
! maximum number of particles in one halo (used if HPID flag enabled)
integer(4), parameter :: ngrid_max = 300
! lower density peak threshold for determining which peaks should be inspected
! as halos
real(4), parameter      :: den_peak_cutoff = 100.
! lower mass cutoff for cataloging a halo, in particles
integer(4), parameter      :: min_halo_particles = 100 
! set .true. to limit initial halo mass calculation to exiting after only
! completing an entire radial shell
logical, parameter      :: complete_shell = .true.
! these are internal and should not be modified
integer(4), parameter   :: nc_halo_max = 128 
integer(4), parameter   :: nlist=(nc_halo_max+1)**3*5
integer(4), parameter   :: max_maxima= 5*nc_halo_max**3
integer(4), parameter   :: max_halo_np = (nc_halo_max+1)**3*5 

!! parameters for timestep constained by fastest moving particle
real(4), parameter :: fbuf = 0.999    !! Fraction of buffer fastest particle can move

!! physical constants
real(4), parameter :: pi = 3.141592654
real(4), parameter :: G = 1.0 / 6.0 / pi
real(4), parameter :: eps = 1.0e-03
real(4), parameter :: threeover4pi = 3. / 4. / pi

!! internal parameters
integer(4), parameter   :: mesh_scale = 4
integer(4), parameter   :: max_np = density_buffer * ( ((nf_tile-2*nf_buf)*tiles_node_dim/2)**3 + &
                                  (8*nf_buf**3 + 6*nf_buf*(((nf_tile-2*nf_buf)*tiles_node_dim)**2) + &
                                  12*(nf_buf**2)*((nf_tile-2*nf_buf)*tiles_node_dim))/8.0 )
integer(4), parameter   :: max_buf = 2 * max_np  !+ (nf_tile/2)**3 
!integer(4), parameter :: max_llf = ( (nf_tile * tiles_node_dim) / 2 )**2 / mesh_scale 
integer(4), parameter :: max_llf = 100000 

integer(4), parameter   :: max_input = 100
integer(4), parameter   :: max_path = 512

integer(4), parameter   :: nodes = nodes_dim * nodes_dim * nodes_dim
integer(4), parameter   :: tiles_node = tiles_node_dim * tiles_node_dim &
                                      * tiles_node_dim

integer(4), parameter   :: nc_buf = nf_buf / mesh_scale

integer(4), parameter   :: nc_tile_dim = ( nf_tile - 2 * nf_buf ) / mesh_scale
integer(4), parameter   :: nc_node_dim = nc_tile_dim * tiles_node_dim
integer(4), parameter   :: nc_dim = nc_node_dim * nodes_dim

integer(4), parameter   :: nodes_slab = nodes_dim * nodes_dim
integer(4), parameter   :: nc_slab = nc_dim / nodes

integer(4), parameter   :: nf_physical_tile_dim = nf_tile - 2 * nf_buf
integer(4), parameter   :: nf_physical_dim = nf_physical_tile_dim &
                                           * tiles_node_dim * nodes_dim
integer(4), parameter   :: nf_physical_node_dim = nf_physical_tile_dim &
                                                * tiles_node_dim

integer(4), parameter   :: hoc_nc_l = 1 - nc_buf
integer(4), parameter   :: hoc_nc_h = nc_node_dim &
                                    + nc_buf
integer(4), parameter   :: hoc_pass_depth = 2 * nc_buf

integer(4), parameter   :: nodes_pen = nodes_dim
integer(4), parameter   :: nc_pen = nc_node_dim / nodes_dim
integer(4), parameter   :: dim_y = nodes_dim
integer(4), parameter   :: dim_z = nodes_dim**2

!! second species ids, note that the exact values don't matter
!! just need to be different
integer(4), parameter :: pid_dm = 1
integer(4), parameter :: pid_nu = 2
